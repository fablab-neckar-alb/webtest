#!/usr/bin/env sh
// 2>/dev/null; exec "$(cd $(dirname $0); yarn bin)"/flow-node"" "$0" "$@"
/**
 * @flow
 * @file Converts color file created by Gamut in Procreate swatches palette.
 * @author Joris Karl Dzaack <hola@arebours.de>
 * @version 0.0.1
 */

/**
 * Module dependencies.
 */

const path = require('path')
const { promisify } = require('util')
const program = require('commander')
const oneColor = require('onecolor')
const AdmZip = require('adm-zip')

/**
 * Promises
 */

const readFile = promisify(require('fs').readFile)
const writeFile = promisify(require('fs').writeFile)
const mkdirp = promisify(require('mkdirp'))

/**
 * Functions
 */

const readJSON = async (f) => {
  try {
    let rawJSON = await readFile(f)

    return JSON.parse(rawJSON)
  } catch (err) {
    return new Error('Cannot read input.')
  }
}

const env = function env () {
  let e = arguments[0]

  if (!e) {
    error('Environment variable must be specified.')
  } else if (typeof arguments[1] !== 'undefined') {
    process.env[e] = arguments[1]
  }

  return process.env[e] === 'true' ? true : process.env[e] === 'false' ? false : process.env[e]
}

const log = (m: string, e: string = '') => {
  if (e) {
    return log(`${e}: ${m}`)
  }

  if (env('VERBOSE') || env('DEBUG')) {
    process.stdout.write(`${m}\n`)
    return m
  }

  return void 0
}

const debug = (m, e = '') => {
  if (e) {
    return debug(`${e}: ${m}`)
  }

  if (env('DEBUG')) {
    process.stdout.write(`${m}\n`)
    return m
  }

  return void 0
}

const error = console.error.bind(console)

const map = (c, a) => Array.prototype.map.call(a, c)

const reduce = (c, i, a) => Array.prototype.reduce.call(a, c, i)

const titleCase = (str, ...val) => map(s => `${s.charAt(0).toUpperCase()}${s.slice(1)}`, reduce((c, v, i) => `${c}${v}${val[i] || ''}`, '', str).split(' ')).join(' ')

/**
 * Defaults
 */

if (!env('DEBUG')) {
  env('DEBUG', false)
}

if (!env('VERBOSE')) {
  env('VERBOSE', false)
}

if (!env('NAME')) {
  env('NAME', require('../package.json').name)
}

/**
 * Main
 */

program
  .version(require('../package.json').version, '-v, --version')
  .option('--input <file>', 'Specify input file')
  .option('--output <file>', 'Specify output file')
  .option('--debug', 'Set debug output', 0)
  .option('--verbose', 'Set verbose output', 0)

program
  .on('option:debug', () => {
    env('DEBUG', program.debug)
  })

program
  .on('option:verbose', () => {
    env('VERBOSE', program.verbose)
  })

program
  .parse(process.argv)

if (!program.input || !program.output) {
  throw new Error('--input and --output are required!')
}

log(`Converting ${program.input} to ${program.output}`)

Promise
  .resolve()
  .then(() => mkdirp(path.dirname(program.output)))
  .then(() => readJSON(program.input))
  .then(data => data.colors)
  .then(data => map(oneColor, data))
  .then(data => map(c => c.hsv(), data))
  .then(data => map(c => ({
    'hue': c.h(),
    'brightness': c.v(),
    'saturation': c.s()
  }), data))
  .then(data => ([{
    name: titleCase`${env('NAME')}`,
    swatches: data
  }]))
  .then(data => JSON.stringify(data))
  .then(data => Buffer.alloc(data.length, data))
  .then(data => {
    let zip = new AdmZip()
    zip.addFile('Swatches.json', data)
    return zip.toBuffer()
  })
  .then((data) => writeFile(program.output, data))
  .then(() => log(`File written to ${program.output}`))
  .catch(e => error(e))
